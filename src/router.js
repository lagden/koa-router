import http from 'node:http'
import compose from 'koa-compose'
import { match } from 'path-to-regexp'

/**
 * Middleware function type.
 *
 * @typedef {(ctx: import('koa').Context & { request: any }, next: import('koa').Next) => Promise<any>} Middleware
 */

/**
 * Determines if the HTTP method of the context matches a specified method.
 *
 * @param {import('koa').Context} ctx - The context object representing the request, containing the method property.
 * @param {string|undefined} method - The HTTP method to match against. If undefined or null, any method will match.
 * @returns {boolean} - Returns true if the method matches, including special handling for 'HEAD' requests when 'GET' is specified.
 */
function matchMethod(ctx, method) {
	if (!method) return true
	if (ctx.method === method) return true
	if (method === 'GET' && ctx.method === 'HEAD') return true
	return false
}

/**
 * Creates a middleware function for a specific HTTP method and path.
 *
 * @param {string|undefined} method - The HTTP method to match against.
 * @param {string} path - The path pattern to match using `path-to-regexp`.
 * @param {(path: string) => boolean | object} checkFn - The function generated by `path-to-regexp` to check path matching.
 * @param {Middleware} routeFn - The function to execute if the route matches.
 * @returns {Middleware} - Returns a middleware function for handling the matched route.
 */
function create(method, path, checkFn, routeFn) {
	return (ctx, next) => {
		// Check if the HTTP method matches
		if (matchMethod(ctx, method) === false) {
			return next()
		}

		// Check if the path matches
		const matchPath = checkFn(ctx.path)
		if (matchPath === false) {
			return next()
		}

		// Decode and assign path parameters to context
		const { params } = matchPath
		for (const k of Object.keys(params)) {
			if (params?.[k]) {
				params[k] = globalThis.decodeURIComponent(params[k])
			}
		}

		// Update context with route path and parameters
		ctx.routePath = ctx.request.routePath = path
		ctx.params = ctx.request.params = params

		// Execute the matched route function
		return routeFn(ctx, next)
	}
}

/**
 * Collects and creates middleware functions for specific HTTP methods and paths.
 *
 * @param {string|undefined} method - The HTTP method to match against.
 * @param {string} path - The path pattern to match using `path-to-regexp`.
 * @param {Middleware[]} fns - Array of middleware functions to apply.
 * @returns {Middleware[]} - Returns an array of middleware functions to handle the route.
 */
function middlewareCollection(method, path, fns) {
	const checkFn = match(path)
	const middleware = []
	for (const fn of fns) {
		// Only add valid functions to the middleware stack
		if (typeof fn === 'function') {
			middleware.push(create(method, path, checkFn, fn))
		}
	}
	return middleware
}

/**
 * Builds a middleware function for a specified HTTP method and path.
 *
 * @param {string|undefined} [method] - The HTTP method for the route.
 * @returns {(path: string|string[], ...fns: Middleware[]) => Middleware} - Returns a function
 *          which accepts a path and route-handling functions that create composed middleware.
 */
function buid(method) {
	if (method) {
		method = method.toUpperCase()
	}

	return (path, ...fns) => {
		if (Array.isArray(path)) {
			const middleware = []
			// Handle array of paths
			for (const p of path) {
				middleware.push(...middlewareCollection(method, p, fns))
			}
			return compose(middleware)
		}
		// Handle single path
		return compose(middlewareCollection(method, path, fns))
	}
}

/**
 * Defines an object mapping HTTP methods to their route-handling functions.
 *
 * @type {{
 *   [method: string]: (path: string|string[], ...handlers: Middleware[]) => Middleware
 * } & {
 *   del: (path: string|string[], ...handlers: Middleware[]) => Middleware,
 *   all: (path: string|string[], ...handlers: Middleware[]) => Middleware
 * }}
 */
const router = {}

// Get all HTTP methods supported by the `http` module and make them lowercase
const methods = http.METHODS?.map((method) => method.toLowerCase())

// Define the router methods for each HTTP method
for (const method of methods) {
	router[method] = buid(method)
}

// Alias for DELETE method
router.del = router.delete

// Create a catch-all route handler
router.all = buid()

export default router
