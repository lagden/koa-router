import http from 'node:http'
import compose from 'koa-compose'
import { match } from 'path-to-regexp'

/**
 * Middleware function type.
 *
 * @typedef {(ctx: Object, next: Function) => any} Middleware
 */

/**
 * Determines if the HTTP method of the context matches a specified method.
 *
 * @param {Object} ctx - The context object representing the request, containing the method property.
 * @param {string|undefined} method - The HTTP method to match against. If undefined or null, any method will match.
 * @returns {boolean} - Returns true if the method matches, including special handling for 'HEAD' requests when 'GET' is specified.
 */
function matchMethod(ctx, method) {
	if (!method) return true
	if (ctx.method === method) return true
	if (method === 'GET' && ctx.method === 'HEAD') return true
	return false
}

/**
 * Creates a middleware function for a specific HTTP method and path.
 *
 * @param {string|undefined} method - The HTTP method to match against.
 * @param {string} path - The path pattern to match using `path-to-regexp`.
 * @param {Function} checkFn - The function generated by `path-to-regexp` to check path matching.
 * @param {Middleware} routeFn - The function to execute if the route matches.
 * @returns {Middleware} - Returns a middleware function for handling the matched route.
 */
function create(method, path, checkFn, routeFn) {
	return (ctx, next) => {
		if (matchMethod(ctx, method) === false) {
			return next()
		}

		const matchPath = checkFn(ctx.path)
		if (matchPath === false) {
			return next()
		}

		const { params } = matchPath
		for (const k of Object.keys(params)) {
			if (params?.[k]) {
				params[k] = globalThis.decodeURIComponent(params[k])
			}
		}

		ctx.routePath = ctx.request.routePath = path
		ctx.params = ctx.request.params = params

		return routeFn(ctx, next)
	}
}

/**
 * Builds a middleware function for a specified HTTP method and path.
 *
 * @param {string|undefined} [method] - The HTTP method for the route.
 * @returns {(path: string, ...fns: Middleware[]) => Middleware} - Returns a function which accepts a path and route-handling functions that creates composed middleware.
 */
function buid(method) {
	if (method) {
		method = method.toUpperCase()
	}

	return (path, ...fns) => {
		const checkFn = match(path)
		const middleware = []
		for (const fn of fns) {
			if (typeof fn === 'function') {
				middleware.push(create(method, path, checkFn, fn))
			}
		}
		return compose(middleware)
	}
}

/**
 * @type {{
 *   [method: string]: (path: string, ...handlers: Middleware[]) => Middleware
 * } & {
 *   del: (path: string, ...handlers: Middleware[]) => Middleware,
 *   all: (path: string, ...handlers: Middleware[]) => Middleware
 * }}
 */
const router = {}
const methods = http.METHODS?.map((method) => method.toLowerCase())

// Define the router methods for each HTTP method
for (const method of methods) {
	router[method] = buid(method)
}

// Alias for DELETE method
router.del = router.delete

// Create a catch-all route handler
router.all = buid()

export default router
